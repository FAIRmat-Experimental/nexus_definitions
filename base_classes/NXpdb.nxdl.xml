<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="nxdlformat.xsl" ?>
<!--
# NeXus - Neutron and X-ray Common Data Format
#
# Copyright (C) 2008-2021 NeXus International Advisory Committee (NIAC)
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 3 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# For further information, see http://www.nexusformat.org
-->
<definition xmlns="http://definition.nexusformat.org/nxdl/3.1"
	category="base"
	name="NXpdb"
	type="group"
	extends="NXobject"
	ignoreExtraGroups="true"
	ignoreExtraFields="true"
	ignoreExtraAttributes="true"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://definition.nexusformat.org/nxdl/3.1 ../nxdl.xsd"
	>

	<!--
		The ignoreExtra* attributes are used in the definition to
		avoid warning messages that would be generated from
		unexpected groups, fields, and attributes.
		Since no groups or attributes are declared here, _every_
		child of this class would generate a warning message without this
		attribute being set to "true".
	-->

	<doc>
		A NeXus transliteration of a PDB file, to be validated only as a PDB
		rather than in NeXus.

		Use :ref:`NXpdb` to incorporate the information in an arbitrary
		PDB or other CIF file into a NeXus file.

		The main suggestion is to use this as a container
		class for a PDB entry to describe a sample in NXsample,
		but it may be more appropriate to place this higher in the
		hierarchy, say in NXentry.

		The structure has to follow the structure of a PDB
		with each PDB data block mapped to a NeXus group of class NXpdb,
		using a lowercase version of the data block name as the name
		of the NeXus group, each PDB category in that data block
		mapped to a NeXus group of class NXpdb and with each PDB column
		mapped to a NeXus field.  Each column in a looped PDB category
		should always be presented as a 1-dimensional array.  The columns 
		in an unlooped PDB category should be presented as scalar values.  
		If a PDB category specifies particular units for columns, the same 
		units should beused for the corresponding fields.

		A PDB entry is unambigous when all information is carried as text.
		All text data should be presented as quoted strings, with the quote
		marks except for the null values "." or "?"

		For clarity in NXpdb form, numeric data may be presented using the
		numeric types specified in the mmCIF dictionary.  In that case,
		if a PDB null value, "." or "?", is contained in a numeric column, the
		IEEE nan should be used for "?" and the IEEE inf should be used for ".".

		An arbitrary DDL2 CIF file can be represented in NeXus using NXpdb.  
		However, if save frames are required, an NXpdb_class  attribute with the
		value "CBF_cbfsf" is required for each NeXus group representing a save
		frame.  NXpdb attributes are not required for other CIF components,
		but may be used to provide internal documentation.

		The nesting of NXpdb groups and datasets that correspond to a CIF with
		two categories and one saveframe, including the NXpdb_class attribues is::

			(datablock1):NXpdb
			   @NXpdb_class:CBF_cbfdb
			   (category1):NXpdb
			     @NXpdb_class:CBF_cbfcat
			      (column_name1):[...]
			      (column_name2):[...]
			      (column_name3):[...]
			      ...
			   (category2):NXpdb
			      @NXpdb_class:CBF_cbfcat
			      (column_name4):[...]
			      (column_name5):[...]
			      (column_name6):[...]
			      ...
			   (saveframe1):NXpdb
			      @NXpdb_class:CBF_cbfsf
			      (category3):NXpdb
			        @NXpdb_class:CBF_cbfcat
			        (column_name7):[...]
			        (column_name8):[...]
			        (column_name9):[...]
			         ...
			      ...
			   ...  

		For example, a PDB entry that begins::

			data_1YVA
			#
			 _entry.id   1YVA
			#
			_audit_conform.dict_name       mmcif_pdbx.dic
			_audit_conform.dict_version    5.279
			_audit_conform.dict_location   http://mmcif.pdb.org/dictionaries/ascii/mmcif_pdbx.dic
			#
			loop_
			_database_2.database_id
			_database_2.database_code
			PDB   1YVA
			RCSB  RCSB031959
			WWPDB D_1000031959
			#

		would produce::
	
			sample:NXsample
			   1yva:NXpdb
			     entry:NXpdb
				 id:"1YVA"
			     audit_conform:NXpdb
				 dict_name:"mmcif_pdbx.dic"
				 dict_version:"5.279"
				 dict_location:"http://mmcif.pdb.org/dictionaries/ascii/mmcif_pdbx.dic"
			     database_2:NXpdb
				 database_id:["PDB","RCSB","WWPDB"]
				 database_code:["1YVA","RCSB031959","D_1000031959"]

		Another example is the following excerpt from pdb entry 9ins, giving the sequences
		of the two chains::

			loop_
			_entity_poly.entity_id
			_entity_poly.nstd_linkage
			_entity_poly.nstd_monomer
			_entity_poly.pdbx_seq_one_letter_code 
			_entity_poly.pdbx_seq_one_letter_code_can
			_entity_poly.type
			1 no no GIVEQCCTSICSLYQLENYCN GIVEQCCTSICSLYQLENYCN polypeptide(L)
			2 no no FVNQHLCGSHLVEALYLVCGERGFFYTPKA FVNQHLCGSHLVEALYLVCGERGFFYTPKA
			polypeptide(L)

		which converts to::

			entity_poly:NXpdb
			  @NXpdb_class:CBF_cbfcat
			  entity_id:["1", "2"]
			  nstd_linkage:["no", "no"]
			  nstd_monomer:["no", "no"]
			  pdbx_seq_one_letter_code:["GIVEQCCTSICSLYQLENYCN","FVNQHLCGSHLVEALYLVCGERGFFYTPKA"]
			  pdbx_seq_one_letter_code_can:["GIVEQCCTSICSLYQLENYCN","FVNQHLCGSHLVEALYLVCGERGFFYTPKA"]
			  type:["polypeptide(L)", "polypeptide(L)"]

		**imgCIF AXIS category vs. NeXus NXtransformations base class**

		Special attention is needed when using CIF categories that may duplicate
		information carried elsewhere in the same NeXus entry.  For example, the
		imgCIF AXIS category and the NeXus NXtransformations base class both
		convey information about positioning of components such as detectors
		and sample goniometers, but use different coordinate systems.  It is
		best to avoid duplication of information if possible, but there are
		times when presentation in both forms is necessary.

		The standard coordinate frame in NeXus is the McStas coordinate frame,
		in which the Z-axis points in the direction of the incident beam, the
		X-axis is orthogonal to the Z-axis in the horizontal plane and pointing
		left as seen from the source and the Y-axis points upwards.  The
		origin is in the sample.
        
		.. image:: ../img/nxpdb_mcstas.png

		The standard coordinate frame in imgCIF/CBF aligns the X-axis to the
		principal goniometer axis, and chooses the Z-axis to point from the sample
		into the beam.  If the beam is not orthogonal to the X-axis, the Z-axis
		is the component of the vector that points into the beam orthogonal to the
		X-axis.  The Y-axis is chosen to complete a right-handed axis system.

		.. image:: ../img/nxpdb_cbf_axes.png
        
		Let us call the NeXus coordinate axes, X_nx, Y_nx and Z_nx, the
		imgCIF/CBF coordinate axes, X_cbf, Y_cbf and Z_cbf and the direction
		of gravity, Gravity.  In order to translate a vector v_nx = ( x, y, z)
		from the NeXus coordinate system to the imgCIF coordinate system, we
		also need two additional axes, as unit vectors, Gravity_cbf the downwards
		direction, and  Beam_cbf, the direction of the beam, e.g. ( 0, 0, -1).   

		In practice, the beam is not necessarily perfectly horizontal, so Y_nx
		is not necessarily perfectly vertical. Therefore, in order to generate
		X_nx, Y_nx and Z_nx some care is needed.  The cross product between two
		vectors a and b is a new vector c orthogonal to both a and b,
		chosen so that a, b, c is a right-handed system.  If a and b are
		orthogonal unit vectors, this right-handed system is an orthonormal
		coordinate system.

		In the CBF coordinate frame, Z_nx is aligned to Beam_cbf:

			Z_nx = Beam_cbf.

		X_nx is defined as being horizontal at right angles to the beam,
		pointing to the left when seen from the source.  Assuming the beam is
		not vertical, we can compute X_nx as the normalized cross product of
		the  beam and gravity:

			X_nx = (Beam_cbf x Gravity_cbf)/||Beam_cbf x Gravity_cbf||.

		To see that this satisfies the constraint of being horizontal and
		pointing to the left, consider the case of Beam = ( 0, 0, -1 )
		and Gravity = ( 0, 0, 1 ); then we would have X_nx = ( 1, 0, 0 )
		from the cross product above.  The normalization is only necessary
		if the beam is not horizontal.

		Finally Y_nx is computed as the cross product of the beam and X_nx,
		completing an orthonormal right-handed system with Y_nx pointing upwards

			Y_nx = Beam_cbf x X_nx.

		Then we know that in the imgCIF/CBF coordinate frame

			v_nx = X.X_nx + Y.Y_nx + Z.Z_nx.

		Thus, given the imgCIF/CBF vectors for the true direction of the beam
		and the true direction of gravity, we have a linear transformation from
		the NeXus coordinate frame to the imgCIF/CBF coordinate frame.   The
		origins of the two frames agree.   The inverse linear transformation will
		transform a vector in the imgCIF/CBF coordinate frame into the NeXus
		coordinate frame.

		In the common case in which the beam is orthogonal to the principal
		goniometer axis so that Beam_cbf = ( 0, 0, -1 ) and the imgCIF/CBF
		Y-axis points upwards, the transformation inverts the X and Z axes.
		In the other common case in which the beam is orthogonal to the
		principal goniometer axis and the imgCIF/CBF Y-axis points
		downwards, the transformation inverts the Y and Z axes.

		For example consider this annotated partial imgCIF axis category ::

			loop_
			_axis.id
			_axis.depends_on
			_axis.equipment
			   _axis.offset[1]  _axis.offset[2]  _axis.offset[3]
			_axis.type
			   _axis.vector[1]  _axis.vector[2]  _axis.vector[3]
			 DETECTOR_X DETECTOR_Y detector
			    0                0                0  # DETECTOR_X offset
			   translation
			    1                0                0  # DETECTOR_X vector
			 DETECTOR_Y DETECTOR_Z detector
			    0                0                0  # DETECTOR_Y offset
			   translation
			    0                -1               0  # DETECTOR_Y vector
			 DETECTOR_Z DETECTOR_2THETA detector 
			    0                0                0  # DETECTOR_Z offset
			   translation
			    0                0                -1 # DETECTOR_Z vector
			 DETECTOR_2THETA '.' detector
			    0                0                0  # DETECTOR_2THETA offset
			   rotation
			    1                0                0  # DETECTOR_2THETA vector
			 GONIOMETER_PHI GONIOMETER_KAPPA goniometer 
			    0                0                0  # GONIOMETER_PHI offset
			   rotation
			    1                0                0  # GONIOMETER_PHI vector
			 GONIOMETER_KAPPA GONIOMETER_OMEGA goniometer 
			    0                0                0  # GONIOMETER_KAPPA offset
			   rotation
			    0.642788         -0.766044        0  # GONIOMETER_KAPPA vector
			 GONIOMETER_OMEGA '.' goniometer 
			    0                0                0  # GONIOMETER_OMEGA offset
			   rotation
			    1                0                0  # GONIOMETER_OMEGA vector
			 GRAVITY '.' gravity 
			    0                0                0  # GRAVITY offset
			   general
			    0                -1               0  # GRAVITY vector
			 SOURCE '.' source 
			    0                0                0  # SOURCE offset
			   general
			    0                0                1  # SOURCE vector

		In translating from imgCIF to NeXus, these axes are distributed to appropriate NeXus
		NXtransformations groups, for example putting the general axes under NXinstrument,
		the detector axes under NXdetector, and the samples goniometer axes under
		NXsample.  Note that extra axes have been added to help document the conversion ::

			   entry:NXentry
			      instrument:NXinstrument
			         transformations:NXtransformations
			            BEAM:
			               @depends_on:.
			               @transformation_type:general
			               @vector [0, 0, 1]
			            CBF_X_:
			               @depends_on:.
			               @transformation_type:general
			               @vector:[-1, 0, 0]
			            CBF_Y_:
			               @depends_on:.
			               @transformation_type:general
			               @vector:[0, 1, 0]
			            CBF_Z_:
			               @depends_on:.
			               @transformation_type:general
			               @vector:[0, 0, -1]
			            GRAVITY:
			               @depends_on:.
			               @transformation_type:general
			               @vector:[0, -1, 0]
			            SOURCE:
			               @depends_on:.
			               @transformation_type:general
			               @vector:[0, 0, -1]
			            UP:
			               @depends_on:.
			               @transformation_type:general
			               @vector:[0, 1, 0]

		Here are the detector/transformations axes::

			         detector:NXdetector"
			            depends_on: "/entry/instrument/detector/transformations/DETECTOR_X"
			            transformations:NXtransformations
			               DETECTOR_2THETA:119
			                  @depends_on:.
			                  @offset:[0, 0, 0]
			                  @offset_units:mm
			                  @transformation_type:rotation
			                  @units:degrees
			                  @vector:[-1, 0, 0]
			               DETECTOR_X:0
			                  @depends_on: "/entry/instrument/detector/transformations/DETECTOR_Y"
			                  @offset:[0, 0, 0]
			                  @offset_units:mm
			                  @transformation_type:translation
			                  @units:mm
			                  @vector:[-1, 0, 0]
			               DETECTOR_Y:0
			                  @depends_on: "/entry/instrument/detector/transformations/DETECTOR_Z"
			                  @offset:[0, 0, 0]
			                  @offset_units:mm
			                  @transformation_type:translation
			                  @units:mm
			                  @vector:[0, -1, 0]
			               DETECTOR_Z:104: "/entry/instrument/detector/transformations/DETECTOR_2THETA"
			                  @offset:[0, 0, 0]
			                  @offset_units:mm
			                  @transformation_type:translation
			                  @units:mm
			                  @vector:[0, 0, 1]

		Here are the sample goniometer axes::

			      sample:"NXsample"
			         depends_on: "/entry/sample/transformations/GONIOMETER_PHI"
			         transformations:NXtransformations
			            GONIOMETER_KAPPA: 70
			               @depends_on": "/entry/sample/transformations/GONIOMETER_OMEGA"
			               @offset:[0, 0, 0]
			               @offset_units:mm"
			               @transformation_type:rotation
			               @units:degrees
			               @vector:[-0.642788, -0.766044, 0]
			            GONIOMETER_OMEGA:23
			               @depends_on:.
			               @offset:[0, 0, 0]
			               @offset_units:mm
			               @transformation_type:rotation
			               @units: "degrees"
			               @vector:[-1, 0, 0]
			            GONIOMETER_PHI:-179
			               @depends_on: "/entry/sample/transformations/GONIOMETER_KAPPA"
			               @offset:[0, 0, 0]
			               @offset_units:mm
			               @transformation_type:rotation
			               @units:degrees
			               @vector:[-1, 0, 0]

		**JungFrau Detector Module Axes in NeXus and CBF/imgcif**
		
		As noted in (H. J. Bernstein, A. Foerster, A. Bhowmick. A. S. Brewster,
		S. Brockhauser, L. Gelisio, D. R. Hall, F. Leonarski, V. Mariani, G. Santoni,
		C. Vonrhein, G. Winter (2020). *Gold Standard for macromolecular
		crystallography diffraction data* IUCrJ 7:5 784-792)
		
		The JUNGFRAU 16M (JF16M) represents a complex detector geometry.... The
		following example shows the depends_on chain for the JF16M SwissFEL data
		set for the zeroth (first) panel. The chain starts with the NXdetector_module
		group at /entry/instrument/ELE_D0/ARRAY_D0Q0M0A0. The group is named after
		its hierarchy, referring to the fact that it is ASIC (application specific
		integrated chip) zero, of module zero, of quadrant zero, of detector zero.
		It has two fields that define the orientation of the panel by specifying
		the fast and slow readout directions for the raw pixel data::
		
		  fast_pixel_direction
		    @offset=0,0,0
		    @vector=-0.9999984140169291,-0.0017810007373656254,0.0
		    @depends_on = /entry/instrument/ELE_D0/transformations/AXIS_D0Q0M0A0
		  slow_pixel_direction
		    @offset=0,0,0
		    @vector=-0.0017810007373656254,0.9999984140169291,0.0
		    @depends_on = /entry/instrument/ELE_D0/transformations/AXIS_D0Q0M0A0
		
		Both the fast and slow pixel directions depend on the AXIS_D0Q0M0A0 field of
		the NXtransformations group at /entry/instrument/ELE_D0/transformations, and
		this field continues the dependency chain of detector groups until the
		final group, which is the detector rail::
		
		  AXIS_D0Q0M0A0
		    @depends_on = AXIS_D0Q0M0
		    @offset = 38.58423053508638,-19.131359799099098,0.0
		    @vector = 0.0,0.0,-1.0
		  AXIS_D0Q0M0
		    @offset = 38.310714303741115,-61.1137814011917,0.0
		    @vector = 0.0,0.0,-1.0
		    @depends_on = AXIS_D0Q0
		  AXIS_D0Q0
		    @offset = 75.1333334212039,-84.65967506456187,0.0
		    @vector = 0.0,0.0,-1.0
		    @depends_on = AXIS_D0
		  AXIS_D0
		    @offset = -0.4290327180241036,0.12102061135945519,-0.294
		    @vector = 0.0,0.0,-1.0
		    @depends_on = AXIS_RAIL
		  AXIS_RAIL
		    @vector = 0.0,0.0,1.0
		    @depends_on = .

		.. image:: ../img/nxpdb_jungfrau16Mschematic.png
		
		Each of the other panels defines a similar set of transforms. We note here
		that this hierarchical arrangement of axes is similar to work performed
		previously for the CSPAD CBF format (A. S. Brewster, J. Hattne, J. M. Parkhurst,
		D. G. Waterman, H. J. Bernstein,G. Winter, N. K. Sauter,(2014). '
		*Comput. Crystallogr. Newsl.* 5, 19-25.]). Aaron Brewster and Asmit Bhowmick
		at LBL, together with Yury Kirienko, Fabio Dall'Antonia and Sandor Brockhauser '
		at EuXFEL, have also worked on similar NeXus master files for the EuXFEL
		AGIPD detector (to be discussed in a future publication).

		In imgCIF, the equivalent information with "# ..." for other axis information
		would appear in the AXIS category as::
		
		  loop_
		 _axis.id
		 _axis.type
		 _axis.equipment
		 _axis.depends_on
		 _axis.vector[1]
		 _axis.vector[2]
		 _axis.vector[3]
		 _axis.offset[1]
		 _axis.offset[2]
		 _axis.offset[3]
		 _axis.equipment_component
		 # ...

		 AXIS_RAIL general detector . 0 0 1 . . .
		         detector_rail
		 AXIS_D0 general detector AXIS_RAIL 0 0 1
		     0.4290327180241036,0.12102061135945519,0.294
		         detector
		 AXIS_D0Q0 general detector AXIS_D0 0 0 1
		     -75.1333334212039,-84.65967506456187,0.0
		         detector_quadrant
		 AXIS_D0Q0M0 general detector AXIS_D0Q0 0 0 1
		     -38.310714303741115,-61.1137814011917,0.0
		         detector_module
		 AXIS_D0Q0M0A0 general detector AXIS_D0Q0M0 0 0 1
		     -38.58423053508638,-19.131359799099098,0.0
		         detector_asic
		 AXIS_D0Q0M0A0_F translation detector AXIS_D0Q0M0A0
		     0.9999984140169291,-0.0017810007373656254,0.0 0 0 0
		         detector_asic
		 AXIS_D0Q0M0A0_S translation detector AXIS_D0Q0M0A0
		     0.0017810007373656254,0.9999984140169291,0.0 0 0 0
		         detector_asic
		 # ...
		
 
 
	</doc>
	<!--
	   NOTE
	   =====

	   NXpdb is a class not validated by the NXDL tools.
		 Do not add any subgroups in this nxdl file.

	   See: https://github.com/nexusformat/definitions/issues/259
	-->
</definition>
