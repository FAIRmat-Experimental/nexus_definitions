category: application
doc: |   
  functional application definition for macromolecular crystallography

symbols: 
  doc: |     
    These symbols will be used below to coordinate datasets
    with the same shape.  Most MX x-ray detectors will produce
    two-dimensional images.  Some will produce three-dimensional
    images, using one of the indices to select a detector module.

  dataRank: | 
    Rank of the ``data`` field

  nP: | 
    Number of scan points

  i: | 
    Number of detector pixels in the slowest direction

  j: | 
    Number of detector pixels in the second slowest direction

  k: | 
    Number of detector pixels in the third slowest direction

  m: | 
    Number of channels in the incident beam spectrum, if known

  groupIndex: |     
    An array of the hierarchical levels of the parents of detector
    elements or groupings of detector elements.
    A top-level element or grouping has parent level -1.

type: group
NXmx(NXobject):
  (NXentry):
    doc: |       
      Note, it is recommended that ``file_name`` and ``file_time`` are included
      as attributes at the root of a file that includes  ':'ref':'`NXmx`. See
      ':'ref':'`NXroot`.
    \@version:
      exists: optional
      doc: |         
        Describes the version of the NXmx definition used to write this data.
        This must be a text (not numerical) representation. Such as':'':'
        
        @version="1.0"
      enumeration: [1.0]
    title(NX_CHAR):
      exists: ['min', '0']
    start_time(NX_DATE_TIME):
      doc: |         
        ISO 8601 time/date of the first data point collected in UTC,
        using the Z suffix to avoid confusion with local time.
        Note that the time zone of the beamline should be provided in
        NXentry/NXinstrument/time_zone.
    end_time(NX_DATE_TIME):
      exists: ['min', '0']
      doc: |         
        ISO 8601 time/date of the last data point collected in UTC,
        using the Z suffix to avoid confusion with local time.
        Note that the time zone of the beamline should be provided in
        NXentry/NXinstrument/time_zone. This field should only be
        filled when the value is accurately observed. If the data
        collection aborts or otherwise prevents accurate recording of
        the end_time, this field should be omitted.
    end_time_estimated(NX_DATE_TIME):
      doc: |         
        ISO 8601 time/date of the last data point collected in UTC,
        using the Z suffix to avoid confusion with local time.
        Note that the time zone of the beamline should be provided in
        NXentry/NXinstrument/time_zone.  This field may be filled
        with a value estimated before an observed value is available.
    definition:
      doc: | 
        NeXus NXDL schema to which this file conforms
      enumeration: [NXmx]
    (NXdata):
      data(NX_NUMBER):
        exists: recommended
        doc: |           
          For a dimension-2 detector, the rank of the data array will be 3.
          For a dimension-3 detector, the rank of the data array will be 4.
          This allows for the introduction of the frame number as the
          first index.
        dimensions:
          rank: dataRank
          dim: [[1, nP], [2, i], [3, j], [4, k]]
    (NXsample):
      name(NX_CHAR):
        doc: | 
          Descriptive name of sample
      depends_on(NX_CHAR):
        doc: |           
          This is a requirement to describe for any scan experiment.
          
          The axis on which the sample position depends may be stored
          anywhere, but is normally stored in the NXtransformations
          group within the NXsample group.
          
          If there is no goniometer, e.g. with a jet, depends_on
          should be set to "."
      (NXtransformations):
        exists: ['min', '0']
        doc: |           
          This is the recommended location for sample goniometer
          and other related axes.
          
          This is a requirement to describe for any scan experiment.
          The reason it is optional is mainly to accommodate XFEL
          single shot exposures.
          
          Use of the depends_on field and the NXtransformations group is
          strongly recommended.  As noted above this should be an absolute
          requirement to have for any scan experiment.
          
          The reason it is optional is mainly to accommodate XFEL
          single shot exposures.
      temperature(NX_NUMBER):
        unit: NX_TEMPERATURE
        exists: ['min', '0']
    (NXinstrument):
      name(NX_CHAR):
        exists: ['min', '1']
        doc: |           
          Name of instrument.  Consistency with the controlled
          vocabulary beamline naming in
          https':'//mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_diffrn_source.pdbx_synchrotron_beamline.html
          and
          https':'//mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_diffrn_source.type.html
          is highly recommended.
        \@short_name:
          exists: optional
          doc: | 
            Short name for instrument, perhaps the acronym.
      time_zone(NX_DATE_TIME):
        exists: recommended
        doc: |           
          ISO 8601 time_zone offset from UTC.
      (NXattenuator):
        exists: ['min', '0']
        attenuator_transmission(NX_NUMBER):
          unit: NX_UNITLESS
          exists: ['min', '0']
      (NXdetector_group):
        exists: recommended
        doc: |           
          Optional logical grouping of detectors.
          
          Each detector is represented as an NXdetector
          with its own detector data array.  Each detector data array
          may be further decomposed into array sections by use of
          NXdetector_module groups.  Detectors can be grouped logically
          together using NXdetector_group. Groups can be further grouped
          hierarchically in a single NXdetector_group (for example, if
          there are multiple detectors at an endstation or multiple
          endstations at a facility).  Alternatively, multiple
          NXdetector_groups can be provided.
          
          The groups are defined hierarchically, with names given
          in the group_names field, unique identifying indices given
          in the field group_index, and the level in the hierarchy
          given in the group_parent field.  For example if an x-ray
          detector group, DET, consists of four detectors in a
          rectangular array':'':'
          
                   DTL    DTR
                   DLL    DLR
          
          We could have':'':'
          
              group_names':' ["DET", "DTL", "DTR", "DLL", "DLR"]
               group_index':' [1, 2, 3, 4, 5]
               group_parent':'  [-1, 1, 1, 1, 1]
        group_names(NX_CHAR):
          doc: |             
            An array of the names of the detectors or the names of
            hierarchical groupings of detectors.
        group_index(NX_INT):
          doc: |             
            An array of unique identifiers for detectors or groupings
            of detectors.
            
            Each ID is a unique ID for the corresponding detector or group
            named in the field group_names.  The IDs are positive integers
            starting with 1.
          dimensions:
            rank: 1
            dim: [[1, i]]
        group_parent(NX_INT):
          doc: |             
            An array of the hierarchical levels of the parents of detectors
            or groupings of detectors.
            
            A top-level grouping has parent level -1.
          dimensions:
            rank: 1
            dim: [[1, groupIndex]]
      (NXdetector):
        doc: |           
          Normally the detector group will have the name ``detector``.
          However, in the case of multiple detectors, each detector
          needs a uniquely named NXdetector.
        depends_on(NX_CHAR):
          exists: ['min', '0']
          doc: |             
            NeXus path to the detector positioner axis that most directly
            supports the detector.  In the case of a single-module
            detector, the detector axis chain may start here.
        (NXtransformations):
          exists: ['min', '0']
          doc: |             
            Location for axes (transformations) to do with the
            detector.  In the case of a single-module detector, the
            axes of the detector axis chain may be stored here.
        (NXcollection):
          exists: ['min', '0']
          doc: |             
            Suggested container for detailed non-standard detector
            information like corrections applied automatically or
            performance settings.
        data(NX_NUMBER):
          exists: recommended
          doc: |             
            For a dimension-2 detector, the rank of the data array will be 3.
            For a dimension-3 detector, the rank of the data array will be 4.
            This allows for the introduction of the frame number as the
            first index.
          dimensions:
            rank: dataRank
            dim: [[1, nP], [2, i], [3, j], [4, k]]
        description:
          exists: recommended
          doc: |             
            name/manufacturer/model/etc. information.
        time_per_channel:
          unit: NX_TIME
          exists: ['min', '0']
          doc: |             
            For a time-of-flight detector this is the scaling
            factor to convert from the numeric value reported to
            the flight time for a given measurement.
        (NXdetector_module):
          exists: ['min', '1', 'max', 'unbounded']
          doc: |             
            Many detectors consist of multiple smaller modules that are
            operated in sync and store their data in a common dataset.
            To allow consistent parsing of the experimental geometry,
            this application definiton requires all detectors to
            define a detector module, even if there is only one.
            
            This group specifies the hyperslab of data in the data
            array associated with the detector that contains the
            data for this module.  If the module is associated with
            a full data array, rather than with a hyperslab within
            a larger array, then a single module should be defined,
            spanning the entire array.
            
            Note, the pixel size is given as values in the array
            fast_pixel_direction and slow_pixel_direction.
          data_origin(NX_INT):
            doc: |               
              A dimension-2 or dimension-3 field which gives the indices
              of the origin of the hyperslab of data for this module in the
              main area detector image in the parent NXdetector module.
              
              The data_origin is 0-based.
              
              The frame number dimension (nP) is omitted.  Thus the
              data_origin field for a dimension-2 dataset with indices (nP, i, j)
              will be an array with indices (i, j), and for a dimension-3
              dataset with indices (nP, i, j, k) will be an array with indices
              (i, j, k).
              
              The ':'ref':'`order <Design-ArrayStorageOrder>` of indices (i, j
              or i, j, k) is slow to fast.
          data_size(NX_INT):
            doc: |               
              Two or three values for the size of the module in pixels in
              each direction. Dimensionality and order of indices is the
              same as for data_origin.
          data_stride(NX_INT):
            exists: ['min', '0']
            doc: |               
              Two or three values for the stride of the module in pixels in
              each direction.  By default the stride is [1,1] or [1,1,1],
              and this is the most likely case.  This optional field is
              included for completeness.
          module_offset(NX_NUMBER):
            unit: NX_LENGTH
            exists: ['min', '0']
            doc: |               
              Offset of the module in regards to the origin of the detector in an
              arbitrary direction.
            \@transformation_type:
              enumeration: [translation]
            \@vector:
              type: NX_NUMBER
            \@offset:
              type: NX_NUMBER
            \@depends_on:
          fast_pixel_direction(NX_NUMBER):
            unit: NX_LENGTH
            doc: |               
              Values along the direction of ':'ref':'`fastest varying <Design-ArrayStorageOrder>`
              pixel direction.  The direction itself is given through the vector
              attribute.
            \@transformation_type:
              enumeration: [translation]
            \@vector:
              type: NX_NUMBER
            \@offset:
              type: NX_NUMBER
            \@depends_on:
          slow_pixel_direction(NX_NUMBER):
            unit: NX_LENGTH
            doc: |               
              Values along the direction of ':'ref':'`slowest varying <Design-ArrayStorageOrder>`
              pixel direction. The direction itself is given through the vector
              attribute.
            \@transformation_type:
              enumeration: [translation]
            \@vector:
              type: NX_NUMBER
            \@offset:
              type: NX_NUMBER
            \@depends_on:
        distance(NX_FLOAT):
          unit: NX_LENGTH
          exists: recommended
          doc: |             
            Distance from the sample to the beam center.
            Normally this value is for guidance only, the proper
            geometry can be found following the depends_on axis chain,
            But in appropriate cases where the dectector distance
            to the sample is observable independent of the axis
            chain, that may take precedence over the axis chain
            calculation.
        distance_derived(NX_BOOLEAN):
          exists: recommended
          doc: |             
            Boolean to indicate if the distance is a derived, rather than
            a primary observation.  If distance_derived true or is not specified,
            the distance is assumed to be derived from detector axis
            specifications.
        dead_time(NX_FLOAT):
          unit: NX_TIME
          exists: ['min', '0']
          doc: |             
            Detector dead time.
        count_time(NX_NUMBER):
          unit: NX_TIME
          exists: recommended
          doc: |             
            Elapsed actual counting time.
        beam_center_derived(NX_BOOLEAN):
          exists: optional
          doc: |             
            Boolean to indicate if the distance is a derived, rather than
            a primary observation.  If true or not provided, that value of
            beam_center_derived is assumed to be true.
        beam_center_x(NX_FLOAT):
          unit: NX_LENGTH
          exists: recommended
          doc: |             
            This is the x position where the direct beam would hit the
            detector. This is a length and can be outside of the actual
            detector. The length can be in physical units or pixels as
            documented by the units attribute.  Normally, this should
            be derived from the axis chain, but the direct specification
            may take precedence if it is not a derived quantity.
        beam_center_y(NX_FLOAT):
          unit: NX_LENGTH
          exists: recommended
          doc: |             
            This is the y position where the direct beam would hit the
            detector. This is a length and can be outside of the actual
            detector. The length can be in physical units or pixels as
            documented by the units attribute.  Normally, this should
            be derived from the axis chain, but the direct specification
            may take precedence if it is not a derived quantity.
        angular_calibration_applied(NX_BOOLEAN):
          exists: ['min', '0']
          doc: |             
            True when the angular calibration has been applied in the
            electronics, false otherwise.
        angular_calibration(NX_FLOAT):
          exists: ['min', '0']
          doc: | 
            Angular calibration data.
          dimensions:
            rank: dataRank
            dim: [[1, i], [2, j], [3, k]]
        flatfield_applied(NX_BOOLEAN):
          exists: ['min', '0']
          doc: |             
            True when the flat field correction has been applied in the
            electronics, false otherwise.
        flatfield(NX_NUMBER):
          exists: ['min', '0']
          doc: |             
            Flat field correction data.  If provided, it is recommended
            that it be compressed.
          dimensions:
            rank: dataRank
            dim: [[1, i], [2, j], [3, k]]
        flatfield_error(NX_NUMBER):
          exists: ['min', '0', 'max', '0']
          doc: |             
            *** Deprecated form.  Use plural form ***
            Errors of the flat field correction data.  If provided, it is recommended
            that it be compressed.
          dimensions:
            rank: dataRank
            dim: [[1, i], [2, j], [3, k]]
        flatfield_errors(NX_NUMBER):
          exists: ['min', '0']
          doc: |             
            Errors of the flat field correction data.  If provided, it is recommended
            that it be compressed.
          dimensions:
            rank: dataRank
            dim: [[1, i], [2, j], [3, k]]
        pixel_mask_applied(NX_BOOLEAN):
          exists: ['min', '0']
          doc: |             
            True when the pixel mask correction has been applied in the
            electronics, false otherwise.
        pixel_mask(NX_INT):
          exists: recommended
          doc: |             
            The 32-bit pixel mask for the detector. Can be either one mask
            for the whole dataset (i.e. an array with indices i, j) or
            each frame can have its own mask (in which case it would be
            an array with indices nP, i, j).
            
            Contains a bit field for each pixel to signal dead,
            blind, high or otherwise unwanted or undesirable pixels.
            They have the following meaning':'
            
                * bit 0':' gap (pixel with no sensor)
                * bit 1':' dead
                * bit 2':' under-responding
                * bit 3':' over-responding
                * bit 4':' noisy
                * bit 5':' -undefined-
                * bit 6':' pixel is part of a cluster of problematic pixels (bit set in addition to others)
                * bit 7':' -undefined-
                * bit 8':' user defined mask (e.g. around beamstop)
                * bits 9-30':' -undefined-
                * bit 31':' virtual pixel (corner pixel with interpolated value)
            
            Normal data analysis software would not take pixels into account
            when a bit in (mask & 0x0000FFFF) is set. Tag bit in the upper
            two bytes would indicate special pixel properties that normally
            would not be a sole reason to reject the intensity value (unless
            lower bits are set.
            
            If the full bit depths is not required, providing a
            mask with fewer bits is permissible.
            
            If needed, additional pixel masks can be specified by
            including additional entries named pixel_mask_N, where
            N is an integer. For example, a general bad pixel mask
            could be specified in pixel_mask that indicates noisy
            and dead pixels, and an additional pixel mask from
            experiment-specific shadowing could be specified in
            pixel_mask_2. The cumulative mask is the bitwise OR
            of pixel_mask and any pixel_mask_N entries.
            
            If provided, it is recommended that it be compressed.
          dimensions:
            rank: 2
            dim: [[1, i], [2, j]]
        countrate_correction_applied(NX_BOOLEAN):
          exists: ['min', '0']
          doc: |             
            Counting detectors usually are not able to measure all incoming particles,
            especially at higher count-rates. Count-rate correction is applied to
            account for these errors.
            
            True when count-rate correction has been applied, false otherwise.
        countrate_correction_lookup_table(NX_NUMBER):
          doc: |             
            The countrate_correction_lookup_table defines the LUT used for count-rate
            correction. It maps a measured count ':'math':'`c` to its corrected value
            ':'math':'`countrate\_correction\_lookup\_table[c]`.
            
            ':'math':'`m` denotes the length of the table.
          dimensions:
            rank: 1
            dim: [[1, m]]
        virtual_pixel_interpolation_applied(NX_BOOLEAN):
          exists: ['min', '0']
          doc: |             
            True when virtual pixel interpolation has been applied, false otherwise.
            
            When virtual pixel interpolation is applied, values of some pixels may
            contain interpolated values. For example, to account for space between
            readout chips on a module, physical pixels on edges and corners between
            chips may have larger sensor areas and counts may be distributed between
            their logical pixels.
        bit_depth_readout(NX_INT):
          exists: recommended
          doc: |             
            How many bits the electronics record per pixel.
        detector_readout_time(NX_FLOAT):
          unit: NX_TIME
          exists: ['min', '0']
          doc: |             
            Time it takes to read the detector (typically milliseconds).
            This is important to know for time resolved experiments.
        frame_time(NX_FLOAT):
          unit: NX_TIME
          exists: ['min', '0']
          doc: |             
            This is time for each frame. This is exposure_time + readout
            time.
        gain_setting(NX_CHAR):
          exists: ['min', '0']
          doc: |             
            The gain setting of the detector. This influences
            background. This is a detector-specific value meant
            to document the gain setting of the detector during
            data collection, for detectors with multiple
            available gain settings.
            
            Examples of gain settings include':'
            
            * ``standard``
            * ``fast``
            * ``auto``
            * ``high``
            * ``medium``
            * ``low``
            * ``mixed high to medium``
            * ``mixed medium to low``
            
            Developers are encouraged to use one of these terms, or to submit
            additional terms to add to the list.
        saturation_value(NX_NUMBER):
          exists: ['min', '0']
          doc: |             
            The value at which the detector goes into saturation.
            Data above this value is known to be invalid.
            
            For example, given a saturation_value and an underload_value,
            the valid pixels are those less than or equal to the
            saturation_value and greater than or equal to the underload_value.
        underload_value(NX_NUMBER):
          exists: ['min', '0']
          doc: |             
            The lowest value at which pixels for this detector
            would be reasonably be measured.
            
            For example, given a saturation_value and an underload_value,
            the valid pixels are those less than or equal to the
            saturation_value and greater than or equal to the underload_value.
        sensor_material(NX_CHAR):
          exists: ['min', '1']
          doc: |             
            At times, radiation is not directly sensed by the detector.
            Rather, the detector might sense the output from some
            converter like a scintillator.
            This is the name of this converter material.
        sensor_thickness(NX_FLOAT):
          unit: NX_LENGTH
          exists: ['min', '1']
          doc: |             
            At times, radiation is not directly sensed by the detector.
            Rather, the detector might sense the output from some
            converter like a scintillator. This is the thickness of this
            converter material.
        threshold_energy(NX_FLOAT):
          unit: NX_ENERGY
          exists: ['min', '0']
          doc: |             
            Single photon counter detectors can be adjusted for a certain
            energy range in which they work optimally. This is the energy
            setting for this.  If the detector supports multiple thresholds,
            this is an array.
        type:
          exists: ['min', '0']
          doc: |             
            Description of type such as scintillator,
            ccd, pixel, image
            plate, CMOS, ...
      (NXbeam):
        exists: ['min', '1']
        \@flux:
          exists: optional
          doc: |             
            Which field contains the measured flux. One of ``flux``,
            ``total_flux``, ``flux_integrated``, or ``total_flux_integrated``.
            
            Alternatively, the name being indicated could be a link
            to a dataset in an NXmonitor group that records per shot beam data.
        incident_wavelength(NX_FLOAT):
          unit: NX_WAVELENGTH
          exists: ['min', '1']
          doc: |             
            In the case of a monchromatic beam this is the scalar
            wavelength.
            
            Several other use cases are permitted, depending on the
            presence or absence of other incident_wavelength_X
            fields.
            
            In the case of a polychromatic beam this is an array of
            length **m** of wavelengths, with the relative weights
            in ``incident_wavelength_weights``.
            
            In the case of a monochromatic beam that varies shot-
            to-shot, this is an array of wavelengths, one for each
            recorded shot. Here, ``incident_wavelength_weights`` and
            incident_wavelength_spread are not set.
            
            In the case of a polychromatic beam that varies shot-to-
            shot, this is an array of length **m** with the relative
            weights in ``incident_wavelength_weights`` as a 2D array.
            
            In the case of a polychromatic beam that varies shot-to-
            shot and where the channels also vary, this is a 2D array
            of dimensions **nP** by **m** (slow to fast) with the
            relative weights in ``incident_wavelength_weights`` as a 2D
            array.
            
            Note, ':'ref':'`variants <Design-Variants>` are a good way
            to represent several of these use cases in a single dataset,
            e.g. if a calibrated, single-value wavelength value is
            available along with the original spectrum from which it
            was calibrated.
        incident_wavelength_weight(NX_FLOAT):
          exists: ['min', '0']
          deprecated: use incident_wavelength_weights, see https':'//github.com/nexusformat/definitions/issues/837
          doc: |             
            In the case of a polychromatic beam this is an array of
            length **m** of the relative weights of the corresponding
            wavelengths in incident_wavelength.
            
            In the case of a polychromatic beam that varies shot-to-
            shot, this is a 2D array of dimensions **nP** by **m**
            (slow to fast) of the relative weights of the
            corresponding wavelengths in incident_wavelength.
        incident_wavelength_weights(NX_FLOAT):
          exists: ['min', '0']
          doc: |             
            In the case of a polychromatic beam this is an array of
            length **m** of the relative weights of the corresponding
            wavelengths in ``incident_wavelength``.
            
            In the case of a polychromatic beam that varies shot-to-
            shot, this is a 2D array of dimensions **np** by **m**
            (slow to fast) of the relative weights of the
            corresponding wavelengths in ``incident_wavelength``.
        incident_wavelength_spread(NX_FLOAT):
          unit: NX_WAVELENGTH
          exists: ['min', '0']
          doc: |             
            The wavelength spread FWHM for the corresponding
            wavelength(s) in incident_wavelength.
            
            In the case of shot-to-shot variation in the wavelength
            spread, this is a 2D array of dimension **nP** by
            **m** (slow to fast) of the spreads of the
            corresponding wavelengths in incident_wavelength.
        incident_wavelength_spectrum(NXdata):
          exists: ['min', '0']
        flux(NX_FLOAT):
          unit: NX_FLUX
          exists: ['min', '0']
          doc: |             
            Flux density incident on beam plane area in photons
            per second per unit area.
            
            In the case of a beam that varies in flux shot-to-shot,
            this is an array of values, one for each recorded shot.
        total_flux(NX_FLOAT):
          unit: NX_FREQUENCY
          exists: ['min', '0']
          doc: |             
            Flux incident on beam plane in photons per second. In other words
            this is the ':'ref':'`flux </NXmx/ENTRY/INSTRUMENT/BEAM/flux-field>` integrated
            over area.
            
            Useful where spatial beam profiles are not known.
            
            In the case of a beam that varies in total flux shot-to-shot,
            this is an array of values, one for each recorded shot.
        flux_integrated(NX_FLOAT):
          unit: NX_PER_AREA
          exists: ['min', '0']
          doc: |             
            Flux density incident on beam plane area in photons
            per unit area. In other words this is the ':'ref':'`flux </NXmx/ENTRY/INSTRUMENT/BEAM/flux-field>`
            integrated over time.
            
            Useful where temporal beam profiles of flux are not known.
            
            In the case of a beam that varies in flux shot-to-shot,
            this is an array of values, one for each recorded shot.
        total_flux_integrated(NX_FLOAT):
          unit: NX_DIMENSIONLESS
          exists: ['min', '0']
          doc: |             
            Flux incident on beam plane in photons. In other words this is the ':'ref':'`flux </NXmx/ENTRY/INSTRUMENT/BEAM/flux-field>`
            integrated over time and area.
            
            Useful where temporal beam profiles of flux are not known.
            
            In the case of a beam that varies in total flux shot-to-shot,
            this is an array of values, one for each recorded shot.
        incident_beam_size(NX_FLOAT):
          unit: NX_LENGTH
          exists: recommended
          doc: |             
            Two-element array of FWHM (if Gaussian or Airy function) or
            diameters (if top hat) or widths (if rectangular) of the beam
            in the order x, y
          dimensions:
            rank: 1
            dim: [[1, 2]]
        profile(NX_CHAR):
          exists: recommended
          doc: |             
            The beam profile, Gaussian, Airy function, top-hat or
            rectangular.  The profile is given in the plane of
            incidence of the beam on the sample.
          enumeration: [Gaussian, Airy, top-hat, rectangular]
        incident_polarisation_stokes(NX_NUMBER):
          exists: optional
          deprecated: use incident_polarization_stokes, see https':'//github.com/nexusformat/definitions/issues/708
          doc: |             
            Polarization vector on entering beamline
            component using Stokes notation
          dimensions:
            rank: 2
            dim: [[1, nP], [2, 4]]
        incident_polarization_stokes(NX_NUMBER):
          exists: recommended
          doc: |             
            Polarization vector on entering beamline
            component using Stokes notation. See
            incident_polarization_stokes in ':'ref':'`NXbeam`
          dimensions:
            rank: 2
            dim: [[1, nP], [2, 4]]
    (NXsource):
      doc: |         
        The neutron or x-ray storage ring/facility. Note, the NXsource base class
        has many more fields available, but at present we only require the name.
      name:
        exists: ['min', '1']
        doc: |           
          Name of source.  Consistency with the naming in
          https':'//mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Items/_diffrn_source.pdbx_synchrotron_site.html
          controlled vocabulary is highly recommended.
        \@short_name:
          exists: optional
          doc: | 
            short name for source, perhaps the acronym
